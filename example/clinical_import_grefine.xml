<html>
<remus_splitter id="file_list">
<![CDATA[
import remus
import gRefine
import re
@remus.splitter
def testfunc( handle ):
	ref = gRefine.Refine( "http://localhost:3333" )
	projects = ref.projectList()
	for projID in projects:
		tmp = re.split( "_", projects[projID]["name"] )
		name = tmp[1]
		remus.emit( projID, name )
]]>

</remus_splitter>
<!-- 
load a csv file and map each row with named columns to the 
sample name (first column)  
-->
<remus_mapper id="mapper_csv" type="python" input=":file_list">
<![CDATA[
import remus
import re
import gRefine
reTab = re.compile(r'\t')
@remus.mapper
def testfunc( key, val ):
	ref = gRefine.Refine( "http://localhost:3333" )
	handle = ref.getTSV( key )
	header = None	
	for line in handle:
		tmp = reTab.split( line.rstrip() )
		if header is None:
			header = []
			for name in tmp:
				if name.startswith( val ):
					header.append( name )
				else:
					header.append( "%s_%s" % (val, name) )
		else:
			out = {}
			for i in range(1, len(tmp)):
				if ( tmp[i] != "null" ):
					out[ header[i] ] = tmp[i]
			if ( len(out) ):
				remus.emit( tmp[0], out )
	handle.close()
]]>
</remus_mapper>

<remus_reducer id="sample_remap" input=":mapper_csv" type="python">
<![CDATA[
import remus
import re
reSample = re.compile(r'^(....\-..\-....)\-(...)')
@remus.reducer
def barcode_remap( key, vals ):
	res = reSample.search( key )
	if res:
		out = { key : [] }
		for val in vals:
			out[key].append( val )
		remus.emit( res.group(1), out )
	else:
		out = { key : [] }
		for val in vals:
			out[key].append( val )
		remus.emit( key, out )
]]>
</remus_reducer>

<remus_reducer id="sample_condence" input=":sample_remap" type="python">
<![CDATA[
import remus
import re
reSample = re.compile(r'^(....\-..\-....)\-(...)')
@remus.reducer
def sample_reduce( key, vals ):
	outmap = {}
	for sampleSet in vals:
		for sampleName in sampleSet:
			if not outmap.has_key( sampleName ):
				outmap[ sampleName ] = {}
			for valSet in sampleSet[ sampleName ]:
				for valKey in valSet:
					if not outmap[sampleName].has_key( valKey ):
						outmap[sampleName][ valKey ] = []
					outmap[sampleName][ valKey ].append( valSet[ valKey ] )
	remus.emit( key, outmap )
]]>
</remus_reducer>

<remus_mapper id="column_map" input=":sample_condence" type="python">
<![CDATA[
import remus
@remus.mapper
def col_map( key, val ):
	for sampleSet in val: 
		for sampleKey in val[sampleSet]:
			for sampleVal in val[sampleSet][ sampleKey ]:
				remus.emit( sampleKey, sampleVal )
]]>
</remus_mapper>

<remus_reducer id="column_enumerate" input=":column_map" type="python" output="enumMap,enumCols,floatCols">
<![CDATA[
import remus
@remus.reducer
def col_map( key, vals ):
	out = {}
	allFloat = True
	first = True
	minVal = None
	maxVal = None	
	for val in vals:
		try:
			if ( val != "null" ):
				i = float(val.replace(",", ""))
				if first:
					minVal = i
					maxVal = i
					first = False
				minVal = min(minVal,i)
				maxVal = max(maxVal,i)
		except ValueError:
			allFloat = False
				
		if not out.has_key( val ):
			out[ val ] = len(out)
	
	if key.count("barcode") == 0 and len(out) > 1:
		if ( allFloat ):
			remus.emit( key, [minVal,maxVal], "floatCols" )
		else:
			remus.emit( key, out, "enumCols" )		
]]>
</remus_reducer>

<remus_mapper id="sample_split" input=":sample_condence" type="python">
<![CDATA[
import remus
import re
reSample = re.compile(r'^(....\-..\-....)\-(...)')
@remus.mapper
def sample_split(key,val):
	for valKey in val:
		res = reSample.search( valKey )
		if res:
			patient = res.group(1)
			out = val[ valKey ]
			if val.has_key( patient ):
				for a in val[ patient ]:
					out[a] = val[patient][a]
			remus.emit( valKey, out )
]]>
</remus_mapper>

<remus_mapper id="sample_vector_split" input=":sample_split" output="point,vector" type="python">
<![CDATA[
import remus
@remus.mapper
def sample_vector_split(key,val):
	vOut = {}
	pOut = {}
	for valKey in val:
		if ( len(val[valKey]) == 1 ):
			pOut[ valKey ] = val[valKey][0]
		else:
			vOut[ valKey ] = val[valKey]
	remus.emit( key, pOut, "point" )
	remus.emit( key, vOut, "vector" )

]]>
</remus_mapper>

<remus_pipe id="enumerated_output" input=":sample_vector_split.point,:column_enumerate.enumCols,:column_enumerate.floatCols" output="col_map,col_order,col_title" type="python">
<![CDATA[
import remus
@remus.pipe
def enumerate_output( inputs ):
	sHandle = inputs[0]
	eHandle = inputs[1]
	fHandle = inputs[2]
	enumMap = {}
	floatMap = {}
	orderMap = {}
	for key, value in eHandle:
		enumMap[ key ] = {}
		for valueKey in value:
			enumMap[ key ][ valueKey ] = value[ valueKey ]
			orderMap[ key ] = len(orderMap)

	floatMap = {}
	for key, value in fHandle:
		floatMap[ key ] = value
		orderMap[ key ] = len(orderMap)

	remus.emit( "titles", sorted( orderMap.keys(), lambda x,y: orderMap[x] - orderMap[y] ), "col_title" )

	for key, value in sHandle:
		out = {}
		col = [None] * len( orderMap )
		for valueKey in value:
			if ( enumMap.has_key( valueKey ) ):
				nVal =  enumMap[valueKey][ value[ valueKey ] ]
				out[ valueKey ] = nVal
				col[ orderMap[ valueKey ] ] = nVal
			elif ( floatMap.has_key( valueKey ) ) :
				nVal = float( value[ valueKey ].replace(",", "") )
				out[ valueKey ] = nVal
				col[ orderMap[ valueKey ] ] = nVal
		remus.emit( key, col, "col_order" )
		remus.emit( key, out, "col_map"   )

]]>
</remus_pipe>

</html>
