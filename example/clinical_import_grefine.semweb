<html>
<semweb_splitter id="file_list">
<![CDATA[
import semweb
import gRefine
@semweb.splitter
def testfunc( handle ):
	ref = gRefine.Refine( "http://localhost:3333" )
	projects = ref.projectList()
	for projID in projects:
		semweb.emit( projID, None )
]]>

</semweb_splitter>
<!-- 
load a csv file and map each row with named columns to the 
sample name (first column)  
-->
<semweb_mapper id="mapper_csv" type="python" input=":file_list">
<![CDATA[
import semweb
import re
import gRefine
reTab = re.compile(r'\t')
@semweb.mapper
def testfunc( key, val ):
	ref = gRefine.Refine( "http://localhost:3333" )
	handle = ref.getTSV( key )
	header = None	
	for line in handle:
		tmp = reTab.split( line.rstrip() )
		if header is None:
			header = tmp
		else:
			out = {}
			for i in range(1, len(tmp)):
				if ( tmp[i] != "null" ):
					out[ header[i] ] = tmp[i]
			semweb.emit( tmp[0], out )
	handle.close()
]]>
</semweb_mapper>
<!--
combine records from the CSV files into connected arrays
-->
<semweb_reducer id="reducer_sequence" input=":mapper_csv" type="python">
<![CDATA[
import semweb
@semweb.reducer
def listReduce( key, vals ):
	semweb.emit( key, vals )
]]>
</semweb_reducer>
<semweb_mapper id="col_map" input=":mapper_csv" type="python">
<![CDATA[
import semweb
@semweb.mapper
def col_map( key, vals ):
	for key2 in vals: 
		semweb.emit( key2, vals[ key2 ] )
]]>
</semweb_mapper>
<semweb_reducer id="col_reduce" input=":col_map" type="python">
<![CDATA[
import semweb
@semweb.reducer
def colcount( key, vals ):
	a = {}
	for val in vals:
		a[ val ] = 1
	semweb.emit( key, a.keys() )
]]>
</semweb_reducer>
<!-- 
Filter out columns that add no data and enumerate colums that do
-->
<semweb_reducer id="col_filter" input=":col_reduce" type="python">
<![CDATA[

skipCol = { "bcr_analyte_barcode" : True, "bcr_aliquot_barcode" : True,
"bcr_examination_barcode" : True, "bcr_radiation_barcode" : True,
"bcr_slide_barcode" : True, "bcr_drug_barcode" : True }

import semweb
@semweb.reducer
def colfilter( key, vals ):
	colType = None
	if (not (len(vals[0]) == 1 and vals[0][0] == "null")) and key.count("barcode") == 0 and not skipCol.has_key( key ):
		allFloat = True
		for val in vals[0]:
			try:
				if ( val != "null" ):
					float(val.replace(",", ""))
			except ValueError:
				allFloat = False
		enumMap = {}
		if allFloat:
			semweb.emit( key, { "::coltype" : "float" } )
			return
		
		allFloat = True
		unitScale = None
		for val in vals[0]:
			try:
				if val != "null":
					tmp = val.split(' ')
					if len(tmp) == 2:
						float(tmp[0].replace(",", ""))
						if ( unitScale is None ):
							unitScale = tmp[1]
						else:
							if unitScale != tmp[1]:
								allFloat = False
					else:
						allFloat = False
			except ValueError:
				allFloat = False
		if allFloat:
			if ( unitScale is not None ):
				semweb.emit( key, { "::new_name" : "%s_%s" % (key, unitScale), "::coltype" : "float", "::unitscale" : unitScale } )
			else:
				semweb.emit( key, { "::new_name" : "%s_%s" % (key, unitScale), "::coltype" : "float" } )
			return

		
		for val in vals[0]:			
			if not enumMap.has_key( val ) and val != "null":
				enumMap[ val ] = len( enumMap )	
		#don't emit enumerations with only value
		if ( len( enumMap ) > 1 ):
			semweb.emit( key, { "::coltype" : "enum", "::enum" : enumMap } )

]]>
</semweb_reducer>


<!--
Flip the CSV values so that are reference by column name,
this way elemnts can removed based on columns that are being removed
-->
<semweb_reducer id="csv_flipper" input=":reducer_sequence" type="python">
<![CDATA[
import semweb
@semweb.reducer
def csv_flipper(key, vals):
	for a in vals:
		for b in a:
			for c in b:
				semweb.emit( c, { key : b[c] } )
]]>
</semweb_reducer>
<!--
Print out the values in columns that are 
-->
<semweb_reducer id="sample_flipper" input=":csv_flipper,:col_filter" type="python">
<![CDATA[
import semweb
@semweb.reducer
def sample_combine( key, vals ):
	outType = None
	enumMap = None
	unitScale = None
	out = []
	for a in vals:
		if a.has_key("::coltype"):
			outType = a["::coltype"]
			if a.has_key( "::enum" ):
				enumMap = a[ "::enum" ]
			if a.has_key("::unitscale" ):
				unitScale = a[ "::unitscale" ]
		else:
			for b in a:
				out.append( ( b, { key : a[b] }) )			
	if outType is not None:
		if enumMap is not None:
			for a in out:
				if enumMap[ a[1][ key ] ] != "null":
					semweb.emit( a[0], { key: enumMap[ a[1][ key ] ] } )
				#else:
				#	semweb.emit( a[0], { key: "null" } )

		else:
			for a in out:
				if a[1][ key ] != "null":
					val = a[1][key].replace(",", "")
					if unitScale is not None:
						semweb.emit( a[0], {key: float(val.replace(unitScale,"") )} )
					else:
						semweb.emit( a[0], {key: float(val) } )
				#else:
				#	semweb.emit( a[0], {key: "null"} )
				
]]>
</semweb_reducer>

<semweb_reducer id="sample_combiner" input=":sample_flipper" type="python">
<![CDATA[
import semweb
@semweb.reducer
def sample_write( key, vals ):
	outmap = {}
	for a in vals:
		for b in a:
			outmap[b] = a[b]
	semweb.emit( key, outmap )

]]>
</semweb_reducer>

<semweb_output id="col_list" input=":col_filter">
<![CDATA[
import semweb
@semweb.output
def col_list( handle ):
	outset = {}
	i = 0
	oHandle = open("codes.tab", "w")
	for a in handle:
		key = a.keys()[0]
		if ( a[ key ][ "::coltype" ] == "enum" ):
			for val in a[ key ][ "::enum" ]:
				oHandle.write("%s\t%s\t%s\t%s\n" % ( "clinical", key, a[ key ][ "::enum" ][ val ], val) )
		outset[ a.keys()[0] ] = i 
		i += 1
	semweb.emit( None, outset )
]]>
</semweb_output>

<semweb_output id="col_2_ra" input=":col_filter" type="python">
<![CDATA[
import semweb
@semweb.output
def col_2_ra( handle ):
	prior = 1
	oHandle = open( "columnDb_clinical.ra", "w" )
	for col in handle:
		name = col.keys()[0]
		oHandle.write("name %s\n" % (name) )
		oHandle.write("shortLabel %s\n" % (name) )
		oHandle.write("longLabel %s\n" % (name) )
		oHandle.write("priority %d\n" % (prior) )
		prior += 1
		oHandle.write("visibility on\n")
		oHandle.write("type lookup sampleCount patientId %s\n" % (name) )
		if ( col[ name ][ "::coltype" ] == "enum" ):
			oHandle.write("filterType coded\n\n")
		else:
			oHandle.write("filterType minMax\n\n")
	oHandle.close()	
]]>
</semweb_output>


<semweb_merger id="col_number" left=":sample_combiner" right=":col_list" type="python">
<![CDATA[
import semweb
@semweb.merger
def col_number( key_left, vals_left, key_right, vals_right ):
	col_order = [ b[0] for b in sorted(  vals_right[0].items(), lambda x,y : y[1] > x[1] ) ]
	vals = vals_left[0]
	out = []
	for col in col_order:
		if vals.has_key( col ):
			out.append( vals[ col ] )
		else:
			out.append( None )
	semweb.emit( key_left, out )
]]>
</semweb_merger>

<semweb_output id="col_print" input=":col_list,:col_number">
<![CDATA[
import semweb
@semweb.output
def col_print( handle ):
	oHandle = open( "col_db.tab", "w" )
	header = None
	for val in handle:
		if header is None:
			header = val
			oHandle.write( "ID\t%s\n" % "\t".join( val.values()[0] ) )
		else:
			a = []
			for b in val.values()[0]:
				if b is None or b == "null":
					a.append( "\N" )
				else:
					a.append( str(b) )
			oHandle.write( "%s\t%s\n" % (val.keys()[0], "\t".join( a ) ) )
]]>
</semweb_output>

</html>
