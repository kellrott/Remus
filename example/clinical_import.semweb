<html>

<!-- 
load a csv file and map each row with named columns to the 
sample name (first column)  
-->
<semweb_mapper id="mapper_csv" type="python" input="fileset.list">
<![CDATA[
import semweb
import re
reTab = re.compile(r'\t')
@semweb.mapper
def testfunc( val ):
	handle = open( val )
	header = None	
	for line in handle:
		tmp = reTab.split( line.rstrip() )
		if header is None:
			header = tmp
		else:
			out = {}
			for i in range(1, len(tmp)):
				out[ header[i] ] = tmp[i]
			semweb.emit( tmp[0], out )
	handle.close()
]]>
</semweb_mapper>
<!--
combine records from the CSV files into connected arrays
-->
<semweb_reducer id="reducer_sequence" input=":mapper_csv" type="python">
<![CDATA[
import semweb
@semweb.reducer
def listReduce( key, vals ):
	semweb.emit( key, vals )
]]>
</semweb_reducer>
<semweb_mapper id="col_map" input=":mapper_csv" type="python">
<![CDATA[
import semweb
@semweb.mapper
def colmap( vals ):
	for key1 in vals:
		for key2 in vals[ key1 ]: 
			semweb.emit( key2, vals[ key1 ][ key2 ] )
]]>
</semweb_mapper>
<semweb_reducer id="col_reduce" input=":col_map" type="python">
<![CDATA[
import semweb
@semweb.reducer
def colcount( key, vals ):
	a = {}
	for val in vals:
		a[ val ] = 1
	semweb.emit( key, a.keys() )
]]>
</semweb_reducer>
<!-- 
Filter out columns that add no data and enumerate colums that do
-->
<semweb_reducer id="col_filter" input=":col_reduce" type="python">
<![CDATA[

skipCol = { "bcr_analyte_barcode" : True, "bcr_aliquot_barcode" : True,
"bcr_examination_barcode" : True, "bcr_radiation_barcode" : True,
"bcr_slide_barcode" : True, "bcr_drug_barcode" : True }

import semweb
@semweb.reducer
def colfilter( key, vals ):
	colType = None
	if (not (len(vals[0]) == 1 and vals[0][0] == "null")) and key.count("barcode") == 0 and not skipCol.has_key( key ):
		allFloat = True
		for val in vals[0]:
			try:
				if ( val != "null" ):
					float(val.replace(",", ""))
			except ValueError:
				allFloat = False
		enumMap = {}
		if allFloat:
			semweb.emit( key, { "::coltype" : "float" } )
			return
		
		allFloat = True
		unitScale = None
		for val in vals[0]:
			try:
				if val != "null":
					tmp = val.split(' ')
					if len(tmp) == 2:
						float(tmp[0].replace(",", ""))
						if ( unitScale is None ):
							unitScale = tmp[1]
						else:
							if unitScale != tmp[1]:
								allFloat = False
					else:
						allFloat = False
			except ValueError:
				allFloat = False
		if allFloat:
			if ( unitScale is not None ):
				semweb.emit( key, { "::new_name" : "%s_%s" % (key, unitScale), "::coltype" : "float", "::unitscale" : unitScale } )
			else:
				semweb.emit( key, { "::new_name" : "%s_%s" % (key, unitScale), "::coltype" : "float" } )
			return

		
		for val in vals[0]:			
			if not enumMap.has_key( val ):
				enumMap[ val ] = len( enumMap )	
		#don't emit enumerations with only value
		if ( len( enumMap ) > 1 ):
			semweb.emit( key, { "::coltype" : "enum", "::enum" : enumMap } )

]]>
</semweb_reducer>


<!--
Flip the CSV values so that are reference by column name,
this way elemnts can removed based on columns that are being removed
-->
<semweb_reducer id="csv_flipper" input=":reducer_sequence" type="python">
<![CDATA[
import semweb
@semweb.reducer
def csv_flipper(key, vals):
	for a in vals:
		for b in a:
			for c in b:
				semweb.emit( c, { key : b[c] } )
]]>
</semweb_reducer>
<!--
Print out the values in columns that are 
-->
<semweb_reducer id="sample_flipper" input=":csv_flipper,:col_filter" type="python">
<![CDATA[
import semweb
@semweb.reducer
def sample_combine( key, vals ):
	outType = None
	enumMap = None
	unitScale = None
	out = []
	for a in vals:
		if a.has_key("::coltype"):
			outType = a["::coltype"]
			if a.has_key( "::enum" ):
				enumMap = a[ "::enum" ]
			if a.has_key("::unitscale" ):
				unitScale = a[ "::unitscale" ]
		else:
			for b in a:
				out.append( ( b, { key : a[b] }) )			
	if outType is not None:
		if enumMap is not None:
			for a in out:
				if enumMap[ a[1][ key ] ] != "null":
					semweb.emit( a[0], { key: enumMap[ a[1][ key ] ] } )
				else:
					semweb.emit( a[0], { key: "null" } )

		else:
			for a in out:
				if a[1][ key ] != "null":
					val = a[1][key].replace(",", "")
					if unitScale is not None:
						semweb.emit( a[0], {key: float(val.replace(unitScale,"") )} )
					else:
						semweb.emit( a[0], {key: float(val) } )
				else:
					semweb.emit( a[0], {key: "null"} )
				
]]>
</semweb_reducer>

<semweb_reducer id="sample_combiner" input=":sample_flipper" type="python">
<![CDATA[
import semweb
@semweb.reducer
def sample_write( key, vals ):
	outmap = {}
	for a in vals:
		for b in a:
			outmap[b] = a[b]
	semweb.emit( key, outmap )

]]>
</semweb_reducer>

<semweb_output id="col_list" input=":col_filter">
<![CDATA[
import semweb
@semweb.output
def col_list( handle ):
	outlist = []
	i = 0
	for a in handle:
		outlist.append( { a.keys()[0] : i } )
		i += 1
	return outlist
]]>
</semweb_output>


<semweb_splitter id="list_splitter" input=":col_list">
<![CDATA[
import semweb
@semweb.splitter
def list_split( data ):
	out = {}
	for val in data:
		for key in val:
			out[ key ] = val[key]
	semweb.emit( "col_names", out )
]]>
</semweb_splitter>

<semweb_output id="col_2_ra" input=":col_filter" type="python">
<![CDATA[
import semweb
@semweb.output
def col_2_ra( handle ):
	prior = 1
	oHandle = open( "columnDb_clinical.ra", "w" )
	for col in handle:
		name = col.keys()[0]
		oHandle.write("name %s\n" % (name) )
		oHandle.write("shortLabel %s\n" % (name) )
		oHandle.write("longLabel %s\n" % (name) )
		oHandle.write("priority %d\n" % (prior) )
		prior += 1
		oHandle.write("visibility on\n")
		oHandle.write("type lookup sampleCount patientId %s\n" % (name) )
		if ( col[ name ][ "::coltype" ] == "enum" ):
			oHandle.write("filterType coded\n\n")
		else:
			oHandle.write("filterType minMax\n\n")
	oHandle.close()	
]]>
</semweb_output>


<semweb_merger id="col_number" left=":sample_combiner" right=":list_splitter" type="python">
<![CDATA[
import semweb
@semweb.merger
def col_number( key_left, vals_left, key_right, vals_right ):
	semweb.emit( key_left, key_right )
]]>
</semweb_merger>

</html>
